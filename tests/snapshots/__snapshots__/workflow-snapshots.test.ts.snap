// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Workflow Snapshots > Config: minimal > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('develop,main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ develop, main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ develop ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            { DOMAINS: "api:\\n  paths:\\n  - 'apps/api/**'\\n" },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: ./.github/actions/detect-changes, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { api: "\${{ fromJSON(steps.detect.outputs.changes).api }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/calculate-version, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'develop' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-tag, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (github.ref_name == 'develop') }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/promote-branch, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ 'main' }}", autoPromote: "\${{ (github.ref_name == 'develop' && 'false') || 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-release, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;

exports[`Workflow Snapshots > Config: multi-domain > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('develop,main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ develop, main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ develop ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            {
              DOMAINS: "api:

                \\  paths:

                \\  - 'apps/api/**'

                \\  - 'libs/api-core/**'

                docs:

                \\  paths:

                \\  - 'docs/**'

                web:

                \\  paths:

                \\  - 'apps/web/**'

                \\  - 'libs/ui/**'\\n"
            },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: ./.github/actions/detect-changes, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { api: "\${{ fromJSON(steps.detect.outputs.changes).api }}", docs: "\${{ fromJSON(steps.detect.outputs.changes).docs }}", web: "\${{ fromJSON(steps.detect.outputs.changes).web }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/calculate-version, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'develop' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-tag, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (github.ref_name == 'develop') }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/promote-branch, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ 'main' }}", autoPromote: "\${{ (github.ref_name == 'develop' && 'false') || 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-release, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;

exports[`Workflow Snapshots > Config: remote-actions > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('develop,main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ develop, main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ develop ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            {
              DOMAINS: "api:

                \\  paths:

                \\  - 'apps/api/**'

                web:

                \\  paths:

                \\  - 'apps/web/**'\\n"
            },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: the-craftlab/pipecraft/actions/detect-changes@v1, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { api: "\${{ fromJSON(steps.detect.outputs.changes).api }}", web: "\${{ fromJSON(steps.detect.outputs.changes).web }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: the-craftlab/pipecraft/actions/calculate-version@v1, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'develop' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: the-craftlab/pipecraft/actions/create-tag@v1, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (github.ref_name == 'develop') }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: the-craftlab/pipecraft/actions/promote-branch@v1, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ 'main' }}", autoPromote: "\${{ (github.ref_name == 'develop' && 'false') || 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: the-craftlab/pipecraft/actions/create-release@v1, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;

exports[`Workflow Snapshots > Config: single-branch > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ main ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            {
              DOMAINS: "app:

                \\  paths:

                \\  - 'src/**'

                \\  - 'lib/**'\\n"
            },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: ./.github/actions/detect-changes, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { app: "\${{ fromJSON(steps.detect.outputs.changes).app }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/calculate-version, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-tag, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (false) }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/promote-branch, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ '' }}", autoPromote: "\${{ 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-release, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;

exports[`Workflow Snapshots > Config: three-branch > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('develop,staging,main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ develop, staging, main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ develop ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            {
              DOMAINS: "backend:

                \\  paths:

                \\  - 'services/**'

                \\  - 'libs/backend/**'

                frontend:

                \\  paths:

                \\  - 'apps/frontend/**'

                \\  - 'libs/ui/**'\\n"
            },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: ./.github/actions/detect-changes, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { backend: "\${{ fromJSON(steps.detect.outputs.changes).backend }}", frontend: "\${{ fromJSON(steps.detect.outputs.changes).frontend }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/calculate-version, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'develop' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-tag, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (github.ref_name == 'develop' || github.ref_name == 'staging') }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/promote-branch, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ github.ref_name == 'develop' && 'staging' || 'main' }}", autoPromote: "\${{ (github.ref_name == 'develop' && 'false') || (github.ref_name == 'staging' && 'false') || 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-release, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;

exports[`Workflow Snapshots > Config: with-auto-merge > should match snapshot 1`] = `
"{
  name: { value: Pipeline },

  permissions: write,

  run-name: "\${{ github.event_name == 'pull_request' && !contains('develop,staging,main', github.head_ref) && github.event.pull_request.title || github.ref_name }} #\${{ inputs.run_number || github.run_number }}\${{ inputs.version && format(' - {0}', inputs.version) || '' }}",

  #Git fetch depth configuration
# - FETCH_DEPTH_AFFECTED: For change detection and Nx affected analysis
#   Lower values (50-100) improve performance, higher values (200+) improve accuracy
#   Use 0 for complete history if your branches diverge significantly
# - FETCH_DEPTH_VERSIONING: For semantic version calculation (needs git tags)
#   Should almost always be 0 to access all tags

#Runtime versions
# Update these to match your project's requirements without regenerating workflows
  env: { FETCH_DEPTH_AFFECTED: { value: "100" }, FETCH_DEPTH_VERSIONING: { value: "0" }, NODE_VERSION: { value: "22" }, PNPM_VERSION: { value: "9" } },

  on: { workflow_dispatch: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, workflow_call: { inputs: { version: { description: The version to deploy, required: false, type: string }, baseRef: { description: The base reference for comparison, required: false, type: string }, run_number: { description: The original run number from develop branch, required: false, type: string }, commitSha: { description: The exact commit SHA to checkout and test, required: false, type: string } } }, push: { branches: [ develop, staging, main ] }, pull_request: { types: [ opened, synchronize, reopened ], branches: [ develop ] } },
  jobs:
    {

      #=============================================================================
    # CHANGES DETECTION (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # This job detects which domains have changed.
    # Domain definitions are baked into this file at generation time.
    # Run 'pipecraft generate' to update when domains change in .pipecraftrc.

      changes:
        {
          runs-on: ubuntu-latest,
          env:
            # Domain configuration (regenerated by pipecraft generate)
            { DOMAINS: "api:\\n  paths:\\n  - 'apps/api/**'\\n" },
          steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_AFFECTED }}" } }, { uses: ./.github/actions/detect-changes, id: detect, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", domains-config: "\${{ env.DOMAINS }}", useNx: 'false', node-version: "\${{ env.NODE_VERSION }}" } } ],
          outputs: { api: "\${{ fromJSON(steps.detect.outputs.changes).api }}", changes: "\${{ steps.detect.outputs.changes }}", affectedDomains: "\${{ steps.detect.outputs.affectedDomains }}", nxAvailable: "\${{ steps.detect.outputs.nxAvailable }}", affectedProjects: "\${{ steps.detect.outputs.affectedProjects }}" }
        },

      #=============================================================================
    # VERSIONING (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Calculates the next semantic version based on conventional commits.
    # Only runs on push events (skipped on pull requests).

      version: { needs: [ changes ], if: "\${{ always() && github.event_name != 'pull_request' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/calculate-version, id: version, with: { baseRef: "\${{ inputs.baseRef || 'main' }}", commitSha: "\${{ inputs.commitSha || github.sha }}", node-version: "\${{ env.NODE_VERSION }}" } } ], outputs: { version: "\${{ steps.version.outputs.version }}" } },
      gate: { runs-on: ubuntu-latest, steps: [ { name: Gate passed, run: echo "All prerequisite jobs succeeded or were skipped - gate allows progression" } ], needs: [ changes, version ], if: "\${{ always() && (needs['changes'].result == 'success' || needs['changes'].result == 'skipped') && (needs['version'].result == 'success' || needs['version'].result == 'skipped') }}" },

      #=============================================================================
    # TAG (⚠️  Managed by Pipecraft - customizable needs and if)
    #=============================================================================
    # Creates git tags and promotes code through branch flow.
    # The 'needs' and 'if' fields are customizable and will be preserved.
    # All other fields (runs-on, steps) are managed by Pipecraft.

      tag: { needs: [ version, gate ], if: "\${{ always() && github.event_name != 'pull_request' && github.ref_name == 'develop' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.gate.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-tag, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] },

      #=============================================================================
    # PROMOTE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Promotes code from develop to staging or main via PR.

      promote: { needs: [ version, tag ], if: "\${{ always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.version.result == 'success' && needs.version.outputs.version != '' && (needs.tag.result == 'success' || needs.tag.result == 'skipped') && (github.ref_name == 'develop' || github.ref_name == 'staging') }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/promote-branch, with: { version: "\${{ needs.version.outputs.version }}", sourceBranch: "\${{ github.ref_name }}", targetBranch: "\${{ github.ref_name == 'develop' && 'staging' || 'main' }}", autoPromote: "\${{ (github.ref_name == 'develop' && 'true') || (github.ref_name == 'staging' && 'false') || 'false' }}", run_number: "\${{ inputs.run_number || github.run_number }}" } } ] },

      #=============================================================================
    # RELEASE (⚠️  Managed by Pipecraft - do not modify)
    #=============================================================================
    # Creates a release for the version.

      release: { needs: [ tag, version ], if: "\${{ always() && github.ref_name == 'main' && needs.version.result == 'success' && needs.version.outputs.version != '' && needs.tag.result == 'success' }}", runs-on: ubuntu-latest, steps: [ { uses: actions/checkout@v4, with: { ref: "\${{ inputs.commitSha || github.sha }}", fetch-depth: "\${{ env.FETCH_DEPTH_VERSIONING }}" } }, { uses: ./.github/actions/create-release, with: { version: "\${{ needs.version.outputs.version }}", commitSha: "\${{ inputs.commitSha || github.sha }}" } } ] }
    }
}
"
`;
