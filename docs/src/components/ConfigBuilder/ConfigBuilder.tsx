import React, { useState, useEffect } from 'react'
import CodeBlock from '@theme/CodeBlock'
import styles from './styles.module.css'

interface DomainConfig {
  paths: string[]
  prefixes: string[]
  description: string
}

interface ConfigState {
  ciProvider: 'github' | 'gitlab'
  mergeStrategy: 'fast-forward' | 'merge'
  requireConventionalCommits: boolean
  packageManager: 'npm' | 'yarn' | 'pnpm'
  initialBranch: string
  finalBranch: string
  branchFlow: string[]
  autoMerge: Record<string, boolean>
  domains: Record<string, DomainConfig>
}

// Template configurations
const TEMPLATES: Record<string, Partial<ConfigState>> = {
  'three-stage-auto': {
    initialBranch: 'develop',
    finalBranch: 'main',
    branchFlow: ['develop', 'staging', 'main'],
    autoMerge: {
      staging: true,
      main: true
    }
  },
  'three-stage-manual': {
    initialBranch: 'develop',
    finalBranch: 'main',
    branchFlow: ['develop', 'staging', 'main'],
    autoMerge: {
      staging: true,
      main: false
    }
  },
  'github-flow': {
    initialBranch: 'main',
    finalBranch: 'main',
    branchFlow: ['main'],
    autoMerge: {}
  },
  'complex-pipeline': {
    initialBranch: 'develop',
    finalBranch: 'main',
    branchFlow: ['develop', 'qa', 'staging', 'pre-prod', 'main'],
    autoMerge: {
      qa: true,
      staging: true,
      'pre-prod': false,
      main: false
    }
  }
}

export default function ConfigBuilder() {
  const [config, setConfig] = useState<ConfigState>({
    ciProvider: 'github',
    mergeStrategy: 'fast-forward',
    requireConventionalCommits: true,
    packageManager: 'npm',
    initialBranch: 'develop',
    finalBranch: 'main',
    branchFlow: ['develop', 'staging', 'main'],
    autoMerge: {
      staging: true,
      main: true
    },
    domains: {
      api: {
        paths: ['apps/api/**'],
        prefixes: ['test', 'deploy'],
        description: 'API application changes'
      },
      web: {
        paths: ['apps/web/**'],
        prefixes: ['test', 'deploy'],
        description: 'Web application changes'
      }
    }
  })

  const [branchFlowInput, setBranchFlowInput] = useState('develop, staging, main')
  const [copiedToast, setCopiedToast] = useState(false)
  const [selectedTemplate, setSelectedTemplate] = useState('three-stage-auto')

  // Update branchFlow and autoMerge when branch flow input changes
  useEffect(() => {
    const branches = branchFlowInput
      .split(',')
      .map(b => b.trim())
      .filter(b => b)

    // Update autoMerge for new branches
    const newAutoMerge: Record<string, boolean> = {}
    branches.forEach((branch, idx) => {
      if (idx > 0) {
        newAutoMerge[branch] = config.autoMerge[branch] ?? true
      }
    })

    setConfig(prev => ({
      ...prev,
      branchFlow: branches,
      autoMerge: newAutoMerge
    }))
  }, [branchFlowInput, config.autoMerge])

  const generateYAML = (): string => {
    let yaml = `# PipeCraft Configuration
# Generated by PipeCraft Configuration Builder

# CI Provider: github or gitlab
ciProvider: ${config.ciProvider}

# Merge Strategy: fast-forward or merge
mergeStrategy: ${config.mergeStrategy}

# Require conventional commit messages
requireConventionalCommits: ${config.requireConventionalCommits}

# Package manager: npm, yarn, or pnpm
packageManager: ${config.packageManager}

# Initial development branch
initialBranch: ${config.initialBranch}

# Final production branch
finalBranch: ${config.finalBranch}

# Ordered branch flow for promotions
branchFlow:
${config.branchFlow.map(b => `  - ${b}`).join('\n')}

# Automatic promotion after successful tests
autoMerge:
${Object.entries(config.autoMerge)
  .map(([branch, enabled]) => `  ${branch}: ${enabled}`)
  .join('\n')}

# Semantic versioning bump rules
semver:
  bumpRules:
    test: ignore
    build: ignore
    ci: patch
    docs: patch
    style: patch
    fix: patch
    perf: patch
    refactor: patch
    chore: patch
    feat: minor
    major: major
    breaking: major

# Domain configuration for independent testing and deployment
domains:
`

    Object.entries(config.domains).forEach(([name, domainConfig]) => {
      const prefixes = (domainConfig as DomainConfig).prefixes || []
      yaml += `  ${name}:
    description: ${(domainConfig as DomainConfig).description}
    paths:
${(domainConfig as DomainConfig).paths.map(p => `      - ${p}`).join('\n')}
    prefixes: [${prefixes.map(p => `'${p}'`).join(', ')}]
`
    })

    return yaml
  }

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(generateYAML())
      setCopiedToast(true)
      setTimeout(() => setCopiedToast(false), 3000)
    } catch (err) {
      console.error('Failed to copy:', err)
    }
  }

  const addDomain = () => {
    const name = prompt('Enter domain name:')
    if (!name || config.domains[name]) {
      if (config.domains[name]) alert('Domain already exists')
      return
    }

    setConfig(prev => ({
      ...prev,
      domains: {
        ...prev.domains,
        [name]: {
          paths: [`apps/${name}/**`],
          prefixes: ['test'],
          description: `${name} changes`
        }
      }
    }))
  }

  const removeDomain = (name: string) => {
    const newDomains = { ...config.domains }
    delete newDomains[name]
    setConfig(prev => ({ ...prev, domains: newDomains }))
  }

  const updateDomain = (name: string, field: string, value: any) => {
    setConfig(prev => ({
      ...prev,
      domains: {
        ...prev.domains,
        [name]: {
          ...prev.domains[name],
          [field]: value
        }
      }
    }))
  }

  const applyTemplate = (templateKey: string) => {
    const template = TEMPLATES[templateKey]
    if (!template) return

    setSelectedTemplate(templateKey)
    setConfig(prev => ({
      ...prev,
      ...template
    }))
    setBranchFlowInput(template.branchFlow?.join(', ') || '')
  }

  return (
    <div className={styles.configBuilder}>
      {/* Template Selector */}
      <div className={styles.fullWidthSection}>
        <div className={styles.section}>
          <div className={styles.templateSelector}>
            <div>
              <h2 style={{ marginBottom: '0.5rem' }}>Start with a Template</h2>
              <p className={styles.helpText}>
                Choose a workflow pattern as a starting point, then customize as needed
              </p>
            </div>
            <select
              value={selectedTemplate}
              onChange={e => applyTemplate(e.target.value)}
              className={styles.templateSelect}
            >
              <option value="three-stage-auto">Three-Stage Flow (auto-merge to production)</option>
              <option value="three-stage-manual">
                Three-Stage Flow (manual merge to production)
              </option>
              <option value="complex-pipeline">
                Complex Pipeline (5-stage with QA and pre-prod)
              </option>
              <option value="github-flow">GitHub Flow (feature → main only)</option>
            </select>
          </div>
        </div>
      </div>

      <div className={`${styles.container} ${styles.firstRow}`}>
        {/* Form Section */}
        <div className={styles.formSection}>
          <div className={styles.section}>
            <h2>Basic Settings</h2>

            <div className={styles.formGroup}>
              <label htmlFor="ciProvider">CI Provider</label>
              <select
                value={config.ciProvider}
                onChange={e => setConfig(prev => ({ ...prev, ciProvider: e.target.value as any }))}
                className={styles.select}
              >
                <option value="github">GitHub Actions</option>
                <option value="gitlab" disabled>
                  GitLab CI (coming soon)
                </option>
              </select>
            </div>

            <div className={styles.formGroup}>
              <label htmlFor="mergeStrategy">Merge Strategy</label>
              <select
                value={config.mergeStrategy}
                onChange={e =>
                  setConfig(prev => ({ ...prev, mergeStrategy: e.target.value as any }))
                }
                className={styles.select}
              >
                <option value="fast-forward">Fast-forward (rebase)</option>
                <option value="merge">Merge commits</option>
              </select>
              <span className={styles.helpText}>How branches should be merged together</span>
            </div>

            <div className={styles.formGroup}>
              <label className={styles.checkboxLabel}>
                <input
                  type="checkbox"
                  checked={config.requireConventionalCommits}
                  onChange={e =>
                    setConfig(prev => ({ ...prev, requireConventionalCommits: e.target.checked }))
                  }
                  disabled
                />
                <span>Require Conventional Commits (always enabled)</span>
              </label>
              <span className={styles.helpText}>
                Conventional commits are required for semantic versioning
              </span>
            </div>

            <div className={styles.formGroup}>
              <label htmlFor="packageManager">Package Manager</label>
              <select
                value={config.packageManager}
                onChange={e =>
                  setConfig(prev => ({ ...prev, packageManager: e.target.value as any }))
                }
                className={styles.select}
              >
                <option value="npm">npm</option>
                <option value="yarn">yarn</option>
                <option value="pnpm">pnpm</option>
              </select>
            </div>
          </div>
        </div>

        {/* Preview Section */}
        <div className={styles.previewSection}>
          <div className={styles.section}>
            <h2>Branch Flow</h2>

            <div className={styles.formGroup}>
              <label htmlFor="initialBranch">Initial Branch (Development)</label>
              <input
                type="text"
                value={config.initialBranch}
                onChange={e => {
                  const newValue = e.target.value.trim()
                  setConfig(prev => ({ ...prev, initialBranch: newValue }))
                  // Update branchFlow input if needed
                  const branches = branchFlowInput.split(',').map(b => b.trim())
                  if (branches.length > 0) {
                    branches[0] = newValue
                    setBranchFlowInput(branches.join(', '))
                  }
                }}
                className={styles.input}
                placeholder="develop"
              />
              <span className={styles.helpText}>The branch where features are first merged</span>
            </div>

            <div className={styles.formGroup}>
              <label htmlFor="finalBranch">Final Branch (Production)</label>
              <input
                type="text"
                value={config.finalBranch}
                onChange={e => {
                  const newValue = e.target.value.trim()
                  setConfig(prev => ({ ...prev, finalBranch: newValue }))
                  // Update branchFlow input if needed
                  const branches = branchFlowInput.split(',').map(b => b.trim())
                  if (branches.length > 0) {
                    branches[branches.length - 1] = newValue
                    setBranchFlowInput(branches.join(', '))
                  }
                }}
                className={styles.input}
                placeholder="main"
              />
              <span className={styles.helpText}>The branch that represents production</span>
            </div>

            <div className={styles.formGroup}>
              <label htmlFor="branchFlow">Branch Flow (comma-separated)</label>
              <input
                type="text"
                value={branchFlowInput}
                onChange={e => setBranchFlowInput(e.target.value)}
                className={styles.input}
                placeholder="develop, staging, main"
              />
              <span className={styles.helpText}>Ordered list of branches for promotion</span>
            </div>
          </div>
        </div>
      </div>

      {/* Full Width Workflow Diagram */}
      <div className={styles.fullWidthSection}>
        <div className={styles.section}>
          <h2>Workflow Diagram</h2>
          <div className={styles.diagram}>
            <div className={styles.branchFlow}>
              {/* Feature branch at the start */}
              <div className={styles.featureBranchBox}>
                <span>feature/*</span>
              </div>
              <div className={`${styles.arrow} ${styles.arrowManual}`}>
                <span className={styles.arrowLabel}>MANUAL</span>
                <span>→</span>
              </div>

              {/* Main branch flow */}
              {config.branchFlow.map((branch, idx) => (
                <React.Fragment key={branch}>
                  <div className={styles.branchBox}>
                    <span>{branch}</span>
                    {branch === config.initialBranch && (
                      <span className={styles.badgeInitial}>DEV</span>
                    )}
                    {branch === config.finalBranch && (
                      <span className={styles.badgeFinal}>PROD</span>
                    )}
                  </div>
                  {idx < config.branchFlow.length - 1 && (
                    <div
                      className={`${styles.arrow} ${
                        config.autoMerge[config.branchFlow[idx + 1]]
                          ? styles.arrowAuto
                          : styles.arrowManual
                      }`}
                    >
                      <span className={styles.arrowLabel}>
                        {config.autoMerge[config.branchFlow[idx + 1]] ? 'AUTO' : 'MANUAL'}
                      </span>
                      <span>→</span>
                    </div>
                  )}
                </React.Fragment>
              ))}
            </div>

            {Object.keys(config.domains).length > 0 && (
              <>
                <h3>Domains</h3>
                <div className={styles.domainGrid}>
                  {Object.entries(config.domains).map(([name, domain]) => {
                    const typedDomain = domain as DomainConfig
                    return (
                      <div key={name} className={styles.domainCard}>
                        <div className={styles.domainCardName}>{name}</div>
                        <div className={styles.domainCardPaths}>
                          {typedDomain.paths[0] || 'No paths'}
                        </div>
                        <div className={styles.domainCardBadges}>
                          {typedDomain.prefixes.length > 0 ? (
                            typedDomain.prefixes.map(prefix => (
                              <span
                                key={prefix}
                                className={`${styles.badge} ${
                                  styles[`badge${prefix.replace('-', '')}`]
                                }`}
                              >
                                {prefix}
                              </span>
                            ))
                          ) : (
                            <span className={styles.noPrefix}>No prefixes</span>
                          )}
                        </div>
                      </div>
                    )
                  })}
                </div>
              </>
            )}
          </div>
        </div>
      </div>

      <div className={styles.container}>
        {/* Left Section: Auto-Merge & Domains */}
        <div className={styles.formSection}>
          <div className={styles.section}>
            <h2>Auto-Merge Configuration</h2>
            <p className={styles.helpText} style={{ marginBottom: '1rem' }}>
              Configure which branches automatically merge after tests pass (vs. requiring manual PR
              approval)
            </p>

            {config.branchFlow.slice(1).map(branch => (
              <div key={branch} className={styles.formGroup}>
                <label className={styles.checkboxLabel}>
                  <input
                    type="checkbox"
                    checked={config.autoMerge[branch] !== false}
                    onChange={e =>
                      setConfig(prev => ({
                        ...prev,
                        autoMerge: {
                          ...prev.autoMerge,
                          [branch]: e.target.checked
                        }
                      }))
                    }
                  />
                  <span>
                    Auto-merge to <strong>{branch}</strong>
                  </span>
                </label>
              </div>
            ))}
          </div>

          <div className={styles.section}>
            <h2>Domains</h2>
            <p className={styles.helpText} style={{ marginBottom: '1rem' }}>
              Define the different parts of your codebase for independent testing and deployment
            </p>

            {Object.entries(config.domains).map(([name, domain]) => (
              <div key={name} className={styles.domainItem}>
                <div className={styles.domainHeader}>
                  <input type="text" value={name} className={styles.domainNameInput} readOnly />
                  <button onClick={() => removeDomain(name)} className={styles.btnRemove}>
                    Remove
                  </button>
                </div>

                <div className={styles.formGroup}>
                  <label htmlFor="description">Description</label>
                  <input
                    type="text"
                    value={(domain as DomainConfig).description}
                    onChange={e => updateDomain(name, 'description', e.target.value)}
                    className={styles.input}
                    placeholder="What does this domain do?"
                  />
                </div>

                <div className={styles.formGroup}>
                  <label htmlFor="paths">Paths (comma-separated globs)</label>
                  <input
                    type="text"
                    value={(domain as DomainConfig).paths.join(', ')}
                    onChange={e =>
                      updateDomain(
                        name,
                        'paths',
                        e.target.value
                          .split(',')
                          .map(p => p.trim())
                          .filter(p => p)
                      )
                    }
                    className={styles.input}
                    placeholder="apps/api/**, src/**"
                  />
                </div>

                <div className={styles.formGroup}>
                  <label htmlFor="prefixes">Prefixes (optional, comma-separated)</label>
                  <input
                    type="text"
                    value={(domain as DomainConfig).prefixes.join(', ')}
                    onChange={e =>
                      updateDomain(
                        name,
                        'prefixes',
                        e.target.value
                          .split(',')
                          .map(p => p.trim())
                          .filter(p => p)
                      )
                    }
                    className={styles.input}
                    placeholder="test, deploy, remote-test (optional)"
                  />
                  <span className={styles.helpText}>
                    Job types to generate (leave empty to skip). Common: test, deploy, remote-test
                  </span>
                </div>
              </div>
            ))}

            <button onClick={addDomain} className={styles.btnAdd}>
              + Add Domain
            </button>
          </div>
        </div>

        {/* Right Section: Generated Configuration */}
        <div className={styles.previewSection}>
          <div className={styles.section}>
            <div className={styles.codeHeader}>
              <h2>Generated Configuration</h2>
              <span className={styles.filename}>.pipecraftrc</span>
            </div>
            <div className={styles.codeBlockWrapper}>
              {/* @ts-expect-error - CodeBlock children type issue with Docusaurus theme */}
              <CodeBlock language="yaml">{generateYAML()}</CodeBlock>
            </div>
            <button onClick={copyToClipboard} className={styles.btnCopy}>
              {copiedToast ? '✓ Copied!' : 'Copy Configuration'}
            </button>
          </div>
        </div>
      </div>

      {copiedToast && <div className={styles.toast}>Configuration copied to clipboard!</div>}
    </div>
  )
}
